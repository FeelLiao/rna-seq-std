---
title: "RNA-Seq Standard Report"
output:
    html_document:
        toc: true
        toc_float: true
    
---

```{r, label="setup", include=FALSE}
library(tidyverse)
library(ggrepel)
library(knitr)
```

## 1.Introduction

In a broad sense, the transcriptome encompasses the complete set of RNA transcripts present within a cell under specific physiological conditions, 
representing the total RNA output of a particular cell type in a defined functional state. 
This includes both messenger RNAs (mRNAs) and non-coding RNAs (ncRNAs). 
Narrowly defined, the transcriptome refers specifically to the full complement of mRNAs. 
In the context of this pipeline, the term RNA specifically pertains to mRNA. 
Transcriptomic research serves as a fundamental approach for elucidating gene function and structure, 
and plays a pivotal role in advancing our understanding of organismal development and the molecular mechanisms underlying disease.

With the continuous advancement of next-generation sequencing technologies and the concurrent decline in sequencing costs, 
RNA sequencing (RNA-seq) has emerged as the predominant method for transcriptome analysis, owing to its high throughput, sensitivity, and broad applicability.

The report is generated using `R Markdown` and is designed to provide a comprehensive overview of the RNA-Seq standard analysis pipeline.
The analysis is performed using the `Snakemake` workflow management system, 
which allows for the automation and reproducibility of the analysis.

In this report, analysis results are structured into several sections, each corresponding to a specific step in the RNA-Seq analysis workflow. The sections include:

**RNA-Seq upstream analysis**

- **Quality Control**: Trim the low quality raw sequencing data using `fastp`, only high quality reads are remained for further analysis.
- **Alignment**: Align clean reads to a reference genome using `HISAT2`.
- **Quantification**: Quantification of gene expression levels using `featureCounts` from `Subread`.  
- **New genes discovery**: Discovery of new genes which were not included in the reference genome annotation using 
`StringTie` and `GffCompare`.

**RNA-Seq downstream analysis**


## 2.Quality Control

Before proceeding with data analysis, it is essential to ensure that the sequencing reads are of sufficiently high quality 
to guarantee the accuracy of downstream analyses. 
In this pipeline, `fastp` was employed to perform stringent quality control on the raw data. 
The filtering criteria were as follows:

1. Removal of reads containing adapter sequences; 
2. Removal of paired reads if either read contains more than 10% ambiguous bases (N); 
3. Removal of paired reads if either read contains more than 50% low-quality bases (Q ≤ 20).

The following table summarizes the quality control results for each sample:

```{r, label="qc_table", echo=FALSE, warning=FALSE, message=FALSE}
qc_table <- read_csv(snakemake@input[["trim"]])
kable(qc_table, align = "l")
```

## 3.Alignment

The sequencing fragments are randomly generated by shearing the mRNA. 
In order to determine which genes these fragments were transcribed from, the clean reads, after quality control, 
need to be aligned to a reference genome. In this study, `HISAT2` was used to align the clean reads to the reference genome, 
providing information on the genomic locations of the reads as well as the sequence features specific to the sequencing samples. 
The `HISAT2` algorithm consists of three main parts:

1. Aligning the sequencing reads to single exons of the genome;
2. Aligning the sequencing reads in segments to two exons of the genome;
3. Aligning the sequencing reads in segments to three or more exons of the genome.

Mapping rate refers to the percentage of mapped reads relative to the total number of clean reads. 
It directly reflects the utilization rate of transcriptome sequencing data. 
If the reference genome is well assembled, the sequenced species matches the reference genome, 
and there is no contamination in the experimental procedures, 
then the proportion of sequencing reads that successfully map to the genome (Total Mapped) is expected to exceed 70%.

The following table summarizes the alignment results for each sample:

```{r, label="alignment_table", echo=FALSE, warning=FALSE, message=FALSE}
alignment_table <- read_csv(snakemake@input[["align"]])
kable(alignment_table, align = "l")
```

## 4.Quantification

Based on the alignment results and the genomic positions of the genes in the reference genome, 
the number of reads mapped to each gene is quantified. 
The number of fragments corresponding to a transcript is influenced by factors such as the amount of sequencing data (or mapped data), 
the length of the transcript, and its expression level. 
To ensure that the fragment count accurately reflects the transcript's expression level, 
normalization is required to account for both the number of mapped reads in each sample and the length of the transcript.

Here, we used TPM (Transcripts Per Million) as the normalization method.
TPM is a normalization method that accounts for both the length of the transcript and the total number of reads in the sample.
The formula for calculating TPM is as follows:

$$TPM=10^6*\frac{reads\ mapped\ to\ transcript\ /\ transcript\ length}{Sum(reads\ mapped\ to\ transcript\ /\ transcript\ length)}$$

The following table shows the first 10 rows of the quantification matrix for each sample:

```{r,label="quantification_table", echo=FALSE, warning=FALSE, message=FALSE}
quantification_table <- read_csv(snakemake@input[["tpm"]])
kable(head(quantification_table, n = 10), align = "l")
```

## 5.New genes discovery

Based on the positional information of the reads aligned to the genome, 
`StringTie` was used to assemble the reads into transcripts. 
`StringTie` employs a network flow algorithm along with optional **de novo** assembly to reconstruct transcript structures. 
Compared to tools such as `Cufflinks`, 
`StringTie` offers improved performance by assembling more complete and accurate transcripts with greater computational efficiency.

The assembled transcripts were then compared with the reference genome annotations using `GffCompare`, 
in order to identify novel transcripts or previously unannotated genes.

The following table shows the discovered new genes in gtf format:

```{r,label="new_genes_table", echo=FALSE, warning=FALSE, message=FALSE}
if (snakemake@params[["newGene"]]) {
  new_genes_gtf_file <- dirname(snakemake@input[["newgene"]]) |>
    file.path("novel_with_exons.gtf")
  if (file.exists(new_genes_gtf_file)) {
    new_genes_table <- read_tsv(new_genes_gtf_file,
      comment = "#",
      col_names = c(
        "seqname", "source", "feature", "start",
        "end", "score", "strand", "frame", "attribute"
      ),
      na = ".",
      col_types = "ccciicccc"
    )
    kable(head(new_genes_table, n = 10), align = "l")
  } else {
    cat("Warning: No new genes discovered.")
  }
} else {
  print("Warning: New genes discovery is not activated!")
}
```

## 6.PCA (Principal Component Analysis)

Multivariate statistical analysis allows for the simplification and dimensionality reduction of high-dimensional and 
complex data while preserving as much of the original information as possible. 
This facilitates the construction of reliable mathematical models to summarize and characterize the expression patterns of the study subjects. 
Among such methods, **Principal Component Analysis (PCA)** is a commonly used unsupervised statistical technique for multidimensional data analysis. 
PCA transforms a set of potentially correlated variables into a set of linearly uncorrelated variables through orthogonal transformation. 
These transformed variables are known as **principal components**.

PCA is widely used to uncover the underlying structure among multiple variables using only a few principal components. 
These components are derived from the original variables and are constructed in such a way that they retain as much of the original variance as possible, 
while remaining mutually uncorrelated. Mathematically, 
this is often achieved by generating linear combinations of the original indicators to form new composite variables.

**Principle of PCA data processing**: The original dataset is compressed into *n* principal components, 
which collectively describe the key features of the original data matrix. **PC1** captures the most dominant feature of the dataset, 
**PC2** captures the most significant feature orthogonal to PC1, and so on, 
with **PC3** to **PCn** following in descending order of explained variance.

### PCA plot

```{r,label="pca_plot", echo=FALSE, warning=FALSE, message=FALSE,fig.align='center', fig.caption='PCA plot of RNA-Seq samples'}
if (snakemake@params[["pca"]]) {
  pca_sample <- read_csv(snakemake@input[["pca_meta"]]) |>
    mutate(dim1 = round(Dim.1, 2), dim2 = round(Dim.2, 2))
  pca_eig <- read_csv(snakemake@input[["pca_eig"]])
  pca_eig1 <- round(pca_eig[1, 3], 2)
  pca_eig2 <- round(pca_eig[2, 3], 2)
  ggplot(data = pca_sample, aes(x = dim1, y = dim2)) +
    geom_point(aes(color = group), size = 4, alpha = 0.4) +
    geom_text_repel(
      aes(label = Sample),
      box.padding = 0.5, # 标签与点间距
      segment.color = "grey50", # 连接线颜色
      max.overlaps = 20, # 最大允许重叠次数
      min.segment.length = 0.2 # 最短连接线长度
    ) +
    theme_bw() +
    labs(
      x = paste("PCA1:", pca_eig1, "%"),
      y = paste("PCA2:", pca_eig2, "%")
    )
} else {
  cat("Warning: PCA is not activated!")
}
```

### PCA eigenvalues

Eigenvectors are the vectors indicating the direction of the axes along which the data varies the most. 
Each eigenvector has a corresponding eigenvalue, quantifying the amount of variance captured along its direction.

PCA involves selecting eigenvectors with the largest eigenvalues. By projecting the original data onto these selected eigenvectors, 
PCA transforms the dataset into a new coordinate system in lower dimensions while retaining the greatest data variances. 
We call these newly aligned coordinates, determined by the eigenvectors, as the principal components.

```{r,label="pca_eig", echo=FALSE, warning=FALSE, message=FALSE}
if (snakemake@params[["pca"]]) {
  pca_eig <- read_csv(snakemake@input[["pca_eig"]])
  kable(pca_eig, align = "l")
} else {
  cat("Warning: PCA is not activated!")
}
```

### PCA meta table

The PCA meta table provides raw information about the PCA plot. 
You can use this table to generate PCA plots with different parameters.

```{r,label="pca_meta", echo=FALSE, warning=FALSE, message=FALSE}
if (snakemake@params[["pca"]]) {
  pca_meta <- read_csv(snakemake@input[["pca_meta"]])
  kable(pca_meta, align = "l")
} else {
  cat("Warning: PCA is not activated!")
}
```

## 7.Differential expression analysis

Differential Gene Expression Analysis is a biological research methodology that identifies genes with statistically significant differences in 
expression levels by comparing biological samples under distinct conditions (e.g., disease vs. control groups, cells or tissues subjected to different treatments). 
Its primary goal is to screen key genes associated with specific phenotypes, diseases, or environmental responses from vast genomic datasets, 
thereby providing critical insights for subsequent functional studies and clinical applications.

The analysis of differential gene expression is a crucial step in RNA-Seq data analysis. Here we used `edgeR` to perform differential expression analysis.
The contrasts were defined as comparison each two pairs.

The final results of differential expression analysis are as follows:

```{r,label="diff_exp_table", echo=FALSE, warning=FALSE, message=FALSE}
if (snakemake@params[["deg"]]) {
  diff_exp_table <- read_csv(snakemake@input[["deg_table"]])
  kable(head(diff_exp_table, n = 10), align = "l")
} else {
  cat("Warning: Differential expression analysis is not activated!")
}
```

## Reference

### Software and Tools

The analysis was performed using the following software and tools:

| Software | Version | Description |
|--------|-------|-----------|
| [fastp](https://github.com/OpenGene/fastp) | 0.24.0 | raw reads quality control |
| [HISAT2](https://github.com/DaehwanKimLab/hisat2) | 2.2.1 | clean reads mapping to reference genome and genome index |
| [Subread](https://github.com/ShiLab-Bioinformatics/subread) | 2.0.8 | transcription quantification: count reads to genomic features |
| [R](https://www.r-project.org/) | 4.3.3 | generate reports and data visualization |
| [Python](https://www.python.org/) | 3.13.0 | integrate shell command with snakemake and process data |